/**
 * This ruleset enforces a strict user-ownership model for the Event Reporter application.
 *
 * Core Philosophy:
 * The security model is built on the principle that users have complete control over their
 * own data, and no access to anyone else's. All data is scoped to the authenticated user,
 * ensuring strong privacy and data isolation from the start.
 *
 * Data Structure:
 * The data structure is straightforward, with a single top-level collection:
 *   - /users/{userId}: Stores private user profile information.
 *
 * Key Security Decisions:
 * - User Data Privacy: All access to a user's document at `/users/{userId}` is restricted
 *   to the authenticated user whose UID matches the `userId` in the path.
 * - No User Enumeration: Listing the top-level `/users` collection is explicitly disallowed.
 *   This is a critical security measure to prevent malicious actors from scraping user emails
 *   or other profile data.
 * - Relational Integrity: On creation, a user document's internal `id` field must match the
 *   document's ID (`userId`) to ensure data consistency. This ID is immutable and cannot be
 *   changed on update.
 *
 * Denormalization for Authorization:
 * This ruleset relies on path-based authorization (`/users/{userId}`), which is highly performant
 * and avoids the need for extra `get()` calls. The user's UID in the path is the sole source
 * of truth for ownership decisions.
 *
 * Structural Segregation:
 * Not applicable in this simple schema, but the pattern of isolating user-specific data into
 * its own collection (`/users`) is a core example of this principle.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    //-------------------------------------------------------------------------
    // Helper Functions
    //-------------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's UID matches the provided userId.
     * This is the primary function for enforcing document ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks for ownership on an existing document. Used for update and delete
     * operations to ensure the target document exists before the operation.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Validates required authorization fields when a User document is created.
     * Enforces that the document's internal ID matches the user's auth UID.
     */
    function hasValidUserDataOnCreate(userId) {
      return request.resource.data.id == userId;
    }

    /**
     * Enforces immutability of critical authorization fields on a User document.
     * The internal user ID cannot be changed after creation.
     */
    function hasValidUserDataOnUpdate() {
      return request.resource.data.id == resource.data.id;
    }


    //-------------------------------------------------------------------------
    // Collection Rules
    //-------------------------------------------------------------------------

    /**
     * @description Manages user profile documents, ensuring users can only access their own data.
     * @path /users/{userId}
     * @allow A user creating their own profile document: `(create) /users/user_abc` where `auth.uid == 'user_abc'`.
     * @deny A user trying to read another user's profile: `(get) /users/user_xyz` where `auth.uid == 'user_abc'`.
     * @principle Restricts access to a user's own data tree.
     */
    match /users/{userId} {
      // READ: Only the document owner can read their own profile. Listing is disabled to prevent user enumeration.
      allow get: if isOwner(userId);
      allow list: if false;

      // WRITE: A user can create their own document, and update or delete it thereafter.
      allow create: if isOwner(userId) && hasValidUserDataOnCreate(userId);
      allow update: if isExistingOwner(userId) && hasValidUserDataOnUpdate();
      allow delete: if isExistingOwner(userId);
    }
  }
}